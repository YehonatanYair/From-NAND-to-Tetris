import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JackTokenizer {
	
	private Scanner reader;
	private Keyword keyword;
	private char symbol;
	private String identifier;
	private int intVal;
	private String stringVal;
	
	private String currentToken;
	private Stack<String> tokensStack = new Stack<>();
	
	JackTokenizer(File file) throws FileNotFoundException{
		reader  = new Scanner(file);
	}
	
	boolean hasMoreTokens(){
		return reader.hasNext();
	}
	
	//This function is used to get the next token from the file, while skipping comments and white spaces in the process.
	void advance() {
		// If the stack of sub-tokens generated by the tokenType() function is not empty, returning them first before continuing reading from file.   
		if(!tokensStack.isEmpty()) {
			currentToken = tokensStack.pop();
		}
		// otherwise, reading from file, while skipping comments.
		else {
			do{
				currentToken = reader.next();
				Pattern p = Pattern.compile("^ *(\\/\\/)?(\\/\\*\\*)?(\\/\\*)?"); //getting rid of comments
				Matcher m = p.matcher(currentToken);
				m.find();
				//The token is a start of a comment paragraph. skipping said paragraph.
				if(m.group(2) != null) {
					currentToken = null;
					String skipping="";
					while(!skipping.equals("*/") && reader.hasNext()) {
						skipping = reader.next();
					}
				}
				// skipping comment line
				else if(m.group(1) != null || m.group(3) != null) {
					if(reader.hasNextLine()) {
						reader.nextLine();
						currentToken = null;
					}
				}
			}
			while(currentToken == null);
		}
	}
	// This function tokenType() usually gets a token from advance() and processes it. if it contains sub-tokens it divides the token to multiple parts and stores in a stack. 
	// otherwise, it returns the type of the token, and stores it in the related field.
	Token tokenType(){	
		Token tokenType;
		if(currentToken == null) {
			return null;
		}

		char lastChar = currentToken.charAt(currentToken.length()-1);
		// if true, The current token has \" in it. reading and concatenating all relevant missing parts of the string constant it is supposed to be.
		if(lastChar != '\"' && currentToken.contains("\"")) {
			if(reader.hasNext()) {
				String tempToken = reader.next();
				boolean nextContainedSymbol = tempToken.contains("\"");
				while(reader.hasNext() && !nextContainedSymbol) {
					currentToken += " " + tempToken;
					tempToken = reader.next();
					nextContainedSymbol = tempToken.contains("\"");
				}
				if(!nextContainedSymbol) {
					System.out.println("ran out of tokens while proccessing a String. This is a problem.");
				}
				//Finished concatenating the String.
				else {
					currentToken += " " + tempToken;
				}
			}
		}
		
		
		lastChar = currentToken.charAt(currentToken.length()-1);
		// The current token ends with a special character. backing up, dividing, and store in stack.
		if(isSpecialChar(lastChar) && currentToken.length() > 1) {
			while(isSpecialChar(lastChar) && currentToken.length() > 1) {
				tokensStack.push("" + lastChar);
				lastChar = currentToken.charAt(currentToken.length()-2);
				currentToken = currentToken.substring(0,currentToken.length()-1);
			}
			tokensStack.push(currentToken);
			//in order for the tokenType function to always return a token, it needs in this case to advance() into the stack and run tokenType() on the sub-token. This is what the following code does.
			advance();
			return tokenType();
		}
		
		
		
		char firstChar = currentToken.charAt(0);
		// The current token starts with a special character. backing up, dividing, and store in stack.
		if(isSpecialChar(firstChar) && currentToken.length() > 1) {
			Stack<String> tempTokensStack = new Stack<>();
			while(isSpecialChar(firstChar) && currentToken.length() > 1) {
				tempTokensStack.push("" + firstChar);
				firstChar = currentToken.charAt(1);
				currentToken = currentToken.substring(1,currentToken.length());
			}
			tokensStack.push(currentToken);
			while(!tempTokensStack.isEmpty()) {
				tokensStack.push(tempTokensStack.pop());
			}
			//in order for the tokenType function to always return a token, it needs in this case to advance() into the stack and run tokenType() on the sub-token. This is what the following code does.
			advance();
			return tokenType();
		}
		
		
		lastChar = currentToken.charAt(currentToken.length()-1);
		if(currentToken.charAt(0) == '\"' || lastChar == '\"') {
			int index;
			if(currentToken.charAt(0) == '\"') {
				//The current Token starts with \", which means by this stage that it is a string constant.
				tokenType = Token.STRING_CONST;
				stringVal = currentToken;
				return tokenType;
			}
			else{ // lastChar == '\"'
				//The current Token ends with \". cutting to two pieces (one, the string, second, the rest) and sending to stack.
				index = currentToken.length()-2;
				while(currentToken.charAt(index) != '\"') {
					index--;
				}
				tokensStack.push(currentToken.substring(index,currentToken.length()));
				if(index > 0) {
					tokensStack.push(currentToken.substring(0,index));
				}
				//in order for the tokenType function to always return a token, it needs in this case to advance() into the stack and run tokenType() on the sub-token. This is what the following code does.
				advance();
				return tokenType();
				
			}
			
		}
		
		Pattern p = Pattern.compile(".+([.\\[\\],\\)\\(]).+"); 
		Matcher m = p.matcher(currentToken);
		// if true, The current token has a special character in the middle. cutting to three and sending to stack.
		if(m.find() && m.group(1) != null && currentToken.length() > 1) {
			int specialChar = currentToken.indexOf(m.group(1));
			tokensStack.push(currentToken.substring(specialChar+1,currentToken.length())); // After The Special Character
			tokensStack.push(m.group(1)); // The Special Character
			tokensStack.push(currentToken.substring(0,specialChar));// Before The Special Character
			//in order for the tokenType function to always return a token, it needs in this case to advance() into the stack and run tokenType() on the sub-token. This is what the following code does.
			advance();
			return tokenType();
		}
		
		//The current token is a keyword. saving value and returning.
		if(isKeyword(currentToken.toUpperCase())) {
			tokenType = Token.KEYWORD;
			this.keyword = Keyword.valueOf(currentToken.toUpperCase());
		}
		//The current token is a symbol. saving value and returning.
		else if (isSpecialChar(currentToken.charAt(0))) {
			tokenType = Token.SYMBOL;
			symbol = currentToken.charAt(0);
			if(currentToken.length()>1) {
				tokensStack.push(currentToken.substring(1,currentToken.length()));
			}
			
		}
		//The current token is a integerConstant. saving value and returning.
		else if(isInteger(currentToken,10)) {
			tokenType = Token.INT_CONST;
			intVal =  Integer.parseInt(currentToken);
		}
		//The current token is a identifier. saving value and returning.
		else {
			tokenType = Token.IDENTIFIER;
			identifier = currentToken;
		}
		return tokenType;
	}
	
	Keyword keyword(){
		return keyword;
	}
	
	char symbol(){
		return symbol;
	}
	
	String identifier(){
		return identifier;
	}
	
	int intVal(){
		return intVal;
	}
	
	String stringVal(){
		return stringVal;
	}
	
	// Helper functions
	
	private static boolean isInteger(String s, int radix) {
	    if(s.isEmpty()) return false;
	    for(int i = 0; i < s.length(); i++) {
	        if(i == 0 && s.charAt(i) == '-') {
	            if(s.length() == 1) return false;
	            else continue;
	        }
	        if(Character.digit(s.charAt(i),radix) < 0) return false;
	    }
	    return true;
	}
	
	private static boolean isSpecialChar(char c) {
		Pattern p = Pattern.compile("[}{)(\\[\\]+.;,*/&|><=~-]"); //group of special characters
		Matcher m = p.matcher(c + "");
		return m.find();
	}
	
	private boolean isKeyword(String curr) {
		for (Keyword k : Keyword.values()) {
	        if (k.name().equals(curr)) {
	            return true;
	        }
	    }
	    return false;
	}
}
